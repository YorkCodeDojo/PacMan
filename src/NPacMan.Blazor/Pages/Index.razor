@page "/"
@using NPacMan.SharedUi
@using NPacMan.Game
@using NPacMan.Blazor.JsInterop
@using NPacMan.SharedUi.Properties
@using System.IO

@inject IJSRuntime jsRuntime

<canvas tabindex="0" @ref="_canvas" style="height: 100%; width: 100%;"></canvas>

@code
{
    private NPacMan.Game.Game? _game;

    private ElementReference _canvas;

    private BoardRenderer? _boardRenderer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        await Setup();

    }

    private async Task Setup()
    {
        // Create and start game

        _game = Game.Create();
        InteropKeyPress.KeyDown += OnKeyDown;
        InteropTouch.TouchStart += TouchStart;
        InteropTouch.TouchEnd += TouchEnd;

        // Pass references of the canvas and spritemap to the javascript code

        await jsRuntime.InvokeVoidAsync("SetupCanvas", _canvas,
            Convert.ToBase64String(Resources.gfx));

        await RegisterSound(Sounds.Chomp, Resources.pacman_chomp);
        await RegisterSound(Sounds.Beginning, Resources.pacman_beginning);
        await RegisterSound(Sounds.Death, Resources.pacman_death);
        await RegisterSound(Sounds.EatFruit, Resources.pacman_eatfruit);
        await RegisterSound(Sounds.EatGhost, Resources.pacman_eatghost);
        await RegisterSound(Sounds.ExtraPac, Resources.pacman_extrapac);
        await RegisterSound(Sounds.Intermission, Resources.pacman_intermission);

        _boardRenderer = new BoardRenderer();

        AddSounds(_game);

        // Don't start game until everything ready

        _game = _game.StartGame();

        // Timer loop

        var timer = new DateTime().AddSeconds(0.5);
        while (true)
        {
            await Task.Delay(1);
            if (DateTime.Now > timer)
            {
                timer = DateTime.Now.AddMilliseconds(50);
                Tick();
            }
        }
    }



    private void Tick()
    {
        try
        {
            if (_boardRenderer != null && _game != null)
            {
                // Get a render plan from the game

                _boardRenderer.RenderStart(_game);

                var jsData = new List<int>();

                // Add any changes to the background

                foreach (var sprite in _boardRenderer.BackgroundToUpdate)
                {
                    jsData.AddRange(Sprite(true, sprite.XPos, sprite.YPos, sprite.Sprite));
                }

                // Add all the sprites for the foreground

                foreach (var sprite in _boardRenderer.SpritesToDisplay)
                {
                    jsData.AddRange(Sprite(false, sprite.XPos, sprite.YPos, sprite.Sprite));
                }

                // Call javascript code to push out onto the screen

                jsRuntime.InvokeVoidAsync("SpriteSet",
                    _boardRenderer.DisplayWidth * PixelGrid, _boardRenderer.DisplayHeight * PixelGrid,
                    jsData.ToArray());
            }
        }
        catch
        {

        }
    }

    private const int PixelGrid = 8;

    // Format a sprite into an array of ints for the javascript code

    private int[] Sprite(bool onBuffer, decimal x, decimal y, SpriteSource source)
    {
        x = x + (1 - source.Size) * 0.5m;
        y = y + (1 - source.Size) * 0.5m;
        var size = PixelGrid * source.Size;
        return new[]
        {
            onBuffer ? 1 : 0,
            PixelGrid * source.XPos, PixelGrid * source.YPos, size,
            (int) (PixelGrid * x), (int) (PixelGrid * y)
        };
    }


    private static readonly IReadOnlyDictionary<ConsoleKey, Direction> KeysMap
        = new Dictionary<ConsoleKey, Direction>{
            {ConsoleKey.UpArrow, Direction.Up},
            {ConsoleKey.DownArrow, Direction.Down},
            {ConsoleKey.LeftArrow, Direction.Left},
            {ConsoleKey.RightArrow, Direction.Right},
                            };

    // Keyboard event

    private async void OnKeyDown(object sender, ConsoleKey e)
    {
        if (_game != null && KeysMap.TryGetValue(e, out var direction))
        {
            await _game.ChangeDirection(direction);
        }
    }

    private int startTouchX = 0;
    private int startTouchY = 0;
    private void TouchStart(object sender, TouchEvent e)
    {
        startTouchX = e.Touches.FirstOrDefault()?.ClientX ?? 0;
        startTouchY = e.Touches.FirstOrDefault()?.ClientY ?? 0;
    }

    private async void TouchEnd(object sender, TouchEvent e)
    {
        var endTouchX = e.ChangedTouches.FirstOrDefault()?.ClientX ?? 0;
        var endTouchY = e.ChangedTouches.FirstOrDefault()?.ClientY ?? 0;


        var xDiff = endTouchX - startTouchX;
        var yDiff = endTouchY - startTouchY;

        if (Math.Abs(xDiff) > Math.Abs(yDiff))
        {
            if (xDiff < 0)
            {
                await _game!.ChangeDirection(Direction.Left);
            }
            else
            {
                await _game!.ChangeDirection(Direction.Right);
            }
        }
        else
        {
            if (yDiff < 0)
            {
                await _game!.ChangeDirection(Direction.Up);
            }
            else
            {
                await _game!.ChangeDirection(Direction.Down);
            }
        }
    }

    private async Task RegisterSound(Sounds sound, UnmanagedMemoryStream ums)
    {
        byte[] bytes;
        using (var ms = new MemoryStream())
        {
            ums.CopyTo(ms);
            bytes = ms.ToArray();
        }
        var data = Convert.ToBase64String(bytes);
        
        await jsRuntime.InvokeVoidAsync("SoundSet", (int)sound, data);
    }

    private enum Sounds
    {
        Chomp,
        Beginning,
        Death,
        EatFruit,
        EatGhost,
        ExtraPac,
        Intermission
    }

    private void PlaySound(Sounds sound)
    {
        jsRuntime.InvokeVoidAsync("PlaySound", (int) sound);
    }

    private void AddSounds(Game game)
    {
        game.Subscribe(GameNotification.Beginning, () => PlaySound(Sounds.Beginning))
            .Subscribe(GameNotification.EatCoin, () => PlaySound(Sounds.Chomp))
            .Subscribe(GameNotification.Respawning, () => PlaySound(Sounds.Death))
            .Subscribe(GameNotification.EatFruit, () => PlaySound(Sounds.EatFruit))
            .Subscribe(GameNotification.EatGhost, () => PlaySound(Sounds.EatGhost))
            .Subscribe(GameNotification.ExtraPac, () => PlaySound(Sounds.ExtraPac))
            .Subscribe(GameNotification.Intermission, () => PlaySound(Sounds.Intermission));
    }
}